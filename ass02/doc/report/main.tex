\documentclass[12pt, a4paper]{report}
\usepackage[pdftex]{graphicx} %for embedding images
\graphicspath{ {./img/} } %the path to the images
\usepackage[,italian, english]{babel}
\usepackage{url} %for proper url entries
% \usepackage[bookmarks, colorlinks=false, pdfborder={0 0 0}, pdftitle={<pdf title here>}, pdfauthor={<author's name here>}, pdfsubject={<subject here>}, pdfkeywords={<keywords here>}]{hyperref} %for creating links in the pdf version and other additional pdf attributes, no effect on the printed document
%\usepackage[final]{pdfpages} %for embedding another pdf, remove if not required
%pseudocode listing packages and definitions
\usepackage{color}
\usepackage{listings}
\usepackage{caption}

\newcounter{nalg}[chapter] % defines algorithm counter for chapter-level
\renewcommand{\thenalg}{\thechapter .\arabic{nalg}} %defines appearance of the algorithm counter
\DeclareCaptionLabelFormat{algocaption}{Algorithm \thenalg} % defines a new caption label as Algorithm x.y

\lstnewenvironment{algorithm}[1][] %defines the algorithm listing environment
{   
    \refstepcounter{nalg} %increments algorithm number
    \captionsetup{labelformat=algocaption,labelsep=colon} %defines the caption setup for: it ises label format as the declared caption label above and makes label and caption text to be separated by a ':'
    \lstset{ %this is the stype
        mathescape=true,
        frame=tB,
        numbers=left, 
        numberstyle=\tiny,
        basicstyle=\scriptsize, 
        keywordstyle=\color{black}\bfseries\em,
        keywords={,input, output, return, datatype, function, in, if, else, foreach, while, begin, end, } %add the keywords you want, or load a language as Rubens explains in his comment above.
        numbers=left,
        xleftmargin=.04\textwidth,
        #1 % this is to add specific settings to an usage of this environment (for instnce, the caption and referable label)
    }
}
{}

\begin{document}
\renewcommand\bibname{References} %Renames "Bibliography" to "References" on ref page


\begin{titlepage}

\begin{center}

\Large \textbf {Programmazione Concorrente e Distribuita - Assigment 02}\\%\\[0.5in]
\vspace{1em}%
\vfill
Andrea Biagini


Filippo Gurioli


Leonardo Randacio
\vspace{1em}
\vfill
{\bf UniversitÃ  di Bologna \\ Scienze e Ingegneria Informatiche}\\[0.5in]

       
\vfill
\today

\end{center}

\end{titlepage}


\tableofcontents
\listoffigures

\newpage
\pagenumbering{arabic} %reset numbering to normal for the main content

\chapter{Macropart 1}
Source code folder: \texttt{macropart1}.

The main classes are located at \texttt{macropart1/simtrafficexamples/}.

The solution for part2 of assignment 01 was slightly modified to use tasks and executors. The master class was modified to use the java \texttt{Executor} and \texttt{ExecutorService} libraries.
The remaining source code from the first assignment was left unaltered.
\chapter{Macropart 2}
\section{Task Decomposition}
The main task can be rappresented in pseudocode with a recursive function \texttt{getWordOccurrences(str URL, str WORD, int DEPTH)}

The function identifies two tasks:
\begin{itemize}
    \item countTask
    \item linkTask
\end{itemize}
The countTask finds all occurrences of the defined word in the website, while the linkTask finds all the links and for every link starts the
 getWordOccurrences on the new url found. Both subtasks are expressed below:

\newpage

\begin{algorithm}[caption={countTask expressed in pseudocode}, label={alg1}]
input: str SITE_CONTENTS, str WORD
output: int
begin
    int COUNT $\gets$ 0
    foreach CURRENT_WORD in SITE_CONTENTS
        if (CURRENT_WORD == WORD)
            COUNT $\gets$ COUNT + 1
        endif
    endforeach
    return COUNT
end       
\end{algorithm}

\begin{algorithm}[caption={linkTask expressed in pseudocode}, label={alg2}]
input: str SITE_CONTENTS, str WORD, int DEPTH
begin
    if (DEPTH != 0)
        foreach CURRENT_WORD in SITE_CONTENTS
            if (is_url(CURRENT_WORD))
                getWordOccurrences(CURRENT_WORD, WORD, DEPTH - 1)
            endif
        endforeach
    endif
end       
\end{algorithm}

\section{Implementation}
To ease development a common View (located at \texttt{macropart2/view}) was created. The View interacts with a common interface: \texttt{WordCounter.java}.
 The various solutions must implement the common interface.

\subsection{Event-loop}
Source code: \texttt{macropart2/eventloop}

The tasks are rappresented by events. The first function call creates an event that parses through the contents of the given website.
 If a url is found and the depth value is not 0 a new event is created, that executes the function on the new website, with the depth value decreased by one.

 The function for each event is rappresented by the following pseudocode:

\newpage

\begin{algorithm}[label={alg3}]
input: str URL, str WORD, int DEPTH
begin
    str SITE_CONTENTS $\gets$ get_site_contents(URL)
    int COUNT $\gets$ 0
    if (DEPTH != 0)
        foreach CURRENT_WORD in SITE_CONTENTS
            if (CURRENT_WORD == WORD)
                COUNT $\gets$ COUNT + 1
            endif
            else if (is_url(CURRENT_WORD))
                addToEventQueue(() -> 
                    getWordOccurrences(CURRENT_WORD, WORD, DEPTH - 1))
        endforeach
    endif
end       
\end{algorithm}

\subsection{Reactive}
Source code: \texttt{macropart2/reactive}

TO BE DONE
\subsection{Virtual Threads}
Source code: \texttt{macropart2/virtualthreads}

The \texttt{WordCounter} implemention creates a virtual thread that executes the following pseudocode:

\newpage

\begin{algorithm}[label={alg5}]
input: str URL, str WORD, int DEPTH
begin
    str SITE_CONTENTS $\gets$ get_site_contents(URL)
    int COUNT $\gets$ 0
    if (DEPTH != 0)
        foreach CURRENT_WORD in SITE_CONTENTS
            if (CURRENT_WORD == WORD)
                COUNT $\gets$ COUNT + 1
            endif
            else if (is_url(CURRENT_WORD))
                VT = create_new_vt(() -> 
                    getWordOccurrences(CURRENT_WORD, WORD, DEPTH - 1))
                join(VT)
        endforeach
    endif
end       
\end{algorithm}

A map monitor is created (\texttt{RWTreeMonitor.java}) to save the current results.

To implement the pausing and resuming functions in the
 \texttt{WordCounter} interface, the \texttt{SimpleSemaphore} class was created: it is a monitor that acts like a resettable barrier. If the
 semaphore is green no threads are blocked. If the semaphore is red all threads block until the semaphore turns green again. The \texttt{WordCounter}
 implementation sets the color of the semaphore depending on orders from the View.

\section{Execution and Testing}
The main class \texttt{macropart2/Main.java} creates the desired implementation of \texttt{WordCounter}.

\subsection{Testing - Event-loop}
The event-loop solution did not show big performance improvements. This was credited to the fact that the event-loop solution is single threaded.
 Enhancements in readability and task decomposition are nonetheless obtained.
%Since the event-loop is single threaded it cannot achieve such a huge performance improvement. It still enhances readability and task decomposition.
\subsection{Testing - Reactive}
TO BE DONE
%TODO
\subsection{Testing - Virtual Threads}
The virtual thread solution proved to be the most efficient, preformance wise. The abstraction of the thread concept empowers the application to be executed
 efficently indipendently from the underlying machine architecture.
\bibliographystyle{plain}
\bibliography{References}

\end{document}