\documentclass[12pt, a4paper]{report}
\usepackage[pdftex]{graphicx} %for embedding images
\graphicspath{ {./img/} } %the path to the images
\usepackage[,italian, english]{babel}
\usepackage{url} %for proper url entries
% \usepackage[bookmarks, colorlinks=false, pdfborder={0 0 0}, pdftitle={<pdf title here>}, pdfauthor={<author's name here>}, pdfsubject={<subject here>}, pdfkeywords={<keywords here>}]{hyperref} %for creating links in the pdf version and other additional pdf attributes, no effect on the printed document
%\usepackage[final]{pdfpages} %for embedding another pdf, remove if not required

\begin{document}
\renewcommand\bibname{References} %Renames "Bibliography" to "References" on ref page


\begin{titlepage}

\begin{center}

\Large \textbf {Programmazione Concorrente e Distribuita - Assigment 01}\\%\\[0.5in]
\vspace{1em}%
\vfill
Leonardo Randacio


Filippo Gurioli


Andrea Biagini
\vspace{1em}
\vfill
{\bf Universit√† di Bologna \\ Scienze e Ingegneria Informatiche}\\[0.5in]

       
\vfill
\today

\end{center}

\end{titlepage}


\tableofcontents
\listoffigures
\listoftables

\newpage
\pagenumbering{arabic} %reset numbering to normal for the main content

\chapter{Analysis}
The goal is to create a concurrent agent-based simulation.

An agent-based simulation or model is a computational modeling
 technique used to simulate complex systems by representing individual
 entities, known as agents, and their interactions within an environment.
 The goal of the simulation is to observe the evolution of the states of the
 environment and the agents in each discrete step.

Agents beheviour for a single step can be described in 3 phases:
\begin{itemize}
   \item sense phase: the agent acquires data from the environment
   \item decide phase: the agent determines the next action
   \item act phase: the action determined is executed on the environment
\end{itemize}

\section{Task Decomposition}
Each agent's step can compose a single task, which can be divided into 3 subtasks,
 one for each phase of the step. 

This means that for a given step there will be 3 tasks:
\begin{itemize}
    \item sense
    \item decide
    \item act
\end{itemize}

The total number of tasks for a given step is 3 * nAgents
 where nAgents is the number of agents

\section{Data Decomposition}
The environment can be subdevided in agent's states which
 means the data can be divided in nAgents indipendent states

\section{Dependency Analysis}
The sense and decide tasks can be joined in a single
 sense-decide task as the sense task only quearies the
 environment and the decide task updates the next action
 to be performed for a given agent. Since the decide phase
 only sets the next action for a given agent and for a
 given step every agent's next action will be set only
 by one decide task, the sense-decide tasks can be executed
 in a concurrent manner.

%The act task must be serialized as the definition imposes that
% a simulation must give the same results indipendently from it
% being implementes sequentialy or concurrently. This means that
% act tasks must be executed in an orderly manner.
The act tasks in a given step can by parallelised between each other, but
 must be executed after the sense-decide task.

The steps of the simulation must be serialized.

\chapter{Design}
Using agenda parallelism we design the system around an agenda
 composed by the various tasks, which were defined earlier. Every
 step in the simulation imposes a mandatory syncronization.

\section{Architecture}
The master-worker architecture is a natural implementation of
 agenda parallelism, using a bag of works. The bag of words is
 implemented as a bounded buffer.

The environment is implemented as a readers-writers monitor, which
 lets threads read from the environment in a parallel manner, but imposes
 that no writing can be executed concurrently with other writing or reading

2 Latches are used for syncronization between master and workers.

\begin{figure}
    \caption{UML diagram showing relationships between monitors, active components and syncronization components}
    \centering
    \includegraphics{UML1.png}
\end{figure}

\chapter{Implementation}
\section{Thread Organization}
The master is implemented as a single thread. The Gui will have a dedicated thread
 managing its events. Depending on the machine architecture, the remaining number
 of instantiable threads are created and used as workers.

\chapter{Deadlock Problems Encountered}
During implementation some deadlock problems arised.

\section{Worker Initialization}
A certain state of the system caused some workers to be left behind.
 After being initialized a worker could start waiting on the workReady latch after
 the master started a step. This caused a deadlock as the worker waited indefenetly
 for the master to signal that the bag was full and the master waited indefenelty for
 all the workers to signal they where ready to recieve other work.

This was solved by having the master wait on the workersReady latch after initializing
 the workers. This way when the first step of the simulation started all workers where
 ready to start, making sure no worker was left behind.

\section{Check and Act}
A certain state of the system caused two workers to access the bag of tasks even though
 only one work remained in it. This meant that one of the workers would complete the task
 while the other one would await on the notEmpty condition of the bag of tasks. Since the
 master waits for all the workers to notify that they are ready for the next tasks, it would
 never fill the bag with new tasks, waiting indefenetly for the awaiting worker to notify
 it was ready to continue. This is a classic check and act problem.
 
This was solved ...

\bibliographystyle{plain}
\bibliography{References}

\end{document}