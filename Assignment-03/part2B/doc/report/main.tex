\documentclass[12pt, a4paper]{report}
\usepackage[pdftex]{graphicx} %for embedding images
\graphicspath{ {./img/} } %the path to the images
\usepackage[,italian, english]{babel}
\usepackage{url} %for proper url entries
% \usepackage[bookmarks, colorlinks=false, pdfborder={0 0 0}, pdftitle={<pdf title here>}, pdfauthor={<author's name here>}, pdfsubject={<subject here>}, pdfkeywords={<keywords here>}]{hyperref} %for creating links in the pdf version and other additional pdf attributes, no effect on the printed document
%\usepackage[final]{pdfpages} %for embedding another pdf, remove if not required

\begin{document}
\renewcommand\bibname{References} %Renames "Bibliography" to "References" on ref page


\begin{titlepage}

\begin{center}

\Large \textbf {Programmazione Concorrente e Distribuita - Assigment 03}\\%\\[0.5in]
\vspace{1em}%
\vfill
Leonardo Randacio


Filippo Gurioli


Andrea Biagini
\vspace{1em}
\vfill
{\bf Universit√† di Bologna \\ Scienze e Ingegneria Informatiche}\\[0.5in]

       
\vfill
\today

\end{center}

\end{titlepage}


\tableofcontents
\listoffigures
\listoftables

\newpage
\pagenumbering{arabic} %reset numbering to normal for the main content

\chapter{Analysis}
The goal is to create a collaborative version of the Sudoku game using the 
 built-in Java library "Java RMI". This library offers the possibility to
 make two separate JVWs commuincate, sharing some objects and using them as
 they were local.

A player can create a sudoku grid (a "grid"), view a list of all the
 available grids, join an available grid and collaborate to its completion
 by adding and removing numbers. Every player can also see where the other
 players have the cursor, to have an idea of what they are doing.

\chapter{Design}
The design has been made keeping in mind that the user has to be kept updated
 reactively of the state of the game and the list of the available grids.

\section{Architecture}
The system has a client-server architecture, where the server has all the
 information and the client can obtain a reference of the object it is
 interested in by asking the server.

\section{Visual Formalisms}
%%% TODO: Complete here!!
\begin{figure}
    \centering
    \includegraphics{UML1.png}
    \caption{UML diagram showing relationships between monitors, active components and syncronization components}
\end{figure}

\begin{figure}
    \centering
    \includegraphics{PetriNetColored.png}
    \caption{Petri net diagram showing the beheviour of the master and workers threads. N is the number of agents in the simulation. The master beheviour is rappresented by 4 places and 4 transitions. The worker is rappresented by one place and one transition. A place containing a token for every step of the simulation regulates the number of steps. Two places rappresent the number of tasks in the bag and the number of tasks finished, regulate the syncronization between master and workers}
\end{figure}

\chapter{Implementation}
Both server and client are implemented in Java, to be able to use the Java RMI
 library. The server part has a model and a tiny controller to have it started;
 every interaction with the user is from the server to the user, so it has been
 chosen to use command line prints. The client is also composed by a model part
 (that in this case is remote) handled by a controller, and a Java Swing GUI to
 interact with grids.

\section{Problems Encountered}
Relevant implementation details emerge from the problems encountered during the
 development.

\subsection{What objects to share, when to share them}
One of the first problems appeared upon deciding how to structure the model
 part. Sharing all the model in a single object would have been unnecessary
 and not secure, making the system heavier in terms of communication between
 components, and making possible to a client to edit a grid it is not
 subscribed on.

The solution was to identify every grid with a unique ID (a String has been
 used) and have an object shared by default to every client, containing a set
 of every available grid; in this way, clients know every available ID. The
 action of subscribing to a certain grid correspond to the client asking a
 remote object referencing the desired grid, and deleting the reference of the
 previously subscribed grid.

\subsection{Remote updates}
While initially testing the system, remote updates where manually asked by the
 user, but one of the objectives was to have a reactively updated GUI.

Two solutions have been found and tested. The first one consisted in a separate
 thread polling the server to obtain updated information. This approach was not
 elegant at all, and resulted in synchronization problems and missed inputs, so
 it has been dismissed. The second solution was to use the observer pattern to
 notify interested clients that an update has been made on the server. This
 approach slightly brakes the RMI part (in fact, it has been not trivial to
 implement) but it is a far more elegant way to manage the problem, inputs
 can't be missed, and clients receive only updates in what they are interested
 in (only the IDs list and the grid they are subscribed to).

\section{Source code organization and execution}
The project is phisically divided in a server package and a client package, but the
 model package is shared between both components.

The project is managed by Gradle, to offer a simple way to execute every
 component: use the task "runServer" to run the server component and the task
 "runClient" to run a client.

%%% TODO: Write conclusions
\chapter{Conclusions}
As stated previously, execution time improvements where mesured. The concurrent version is consequently more scalable, as the number of workers is computer based on the number fo cores available. The difference in the execution times detected between the two kind of \texttt{RunMassiveTrafficSimulation} seems too little. We came up with the idea that the bottleneck on our application is the large use of data structures. All workers do not have any state inside, leading to the necessity to store the state of every agent on a seperate data structure (AgentWills) to be retrieved at a further time.

\bibliographystyle{plain}
\bibliography{References}

\end{document}